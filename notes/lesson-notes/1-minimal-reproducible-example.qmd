---
title: "Minimal, reproducible example"
---

# Where to ask for help

Consider <a href="https://stackoverflow.com">StackOverflow</a>! Always look for extisting answers to your question first, then post!
AI (LLMs) can be a good help for simple cases but for more complex things will often give you code that breaks easily. Can also at times be esoteric and difficult to debug.

There is no shame in using LLMs as long as one is aware of these issues. In fact, LLMs can be a great way of turning your headache into a well-formed question.

# What is a minimal, reproducible example (MRE)

When presenting your problem to others, it can be very helpful to move away from the full dataset and ALL the code, and create a miniature version of your problem; <a href="https://stackoverflow.com/help/minimal-reproducible-example">an MRE</a>.

1. Minimal: The example should use as little code and data as possible to produce the problem

2. Complete: Your question should contain ALL the information needed to reproduce the problem.

3. Reproducible: Make sure the code and data provided ACTUALLY reproduce the same problem (and not a different one)

Create the code example by building it up step-by-step until the problem appears. Alternatively, build up the whole code and remove bits at a time, until the problem disappears - then reinsert the last part that was removed.

# How to simulate a dataset

Here are some good functions to know when creating a mock dataset.

## Setting the random seed

Before doing any random operations, setting the seed to a fixed value will ensure that the code produces exactly the same output every time:

```{r}
set.seed(12345)
rpois(5, 10)

set.seed(12345)
rpois(5, 10) 

set.seed(23)
rpois(5, 10)
```


## Sampling from a distribution

```{r}
N <- 20
```

### The normal distribution
```{r}
# The normal distribution
rnorm(n = N, mean = 65, sd = 7)
```

### The binomial distribution
```{r}
# size = number of flips of the coin. E.g., size=1 and prob = 0.3 gives you a binary variable, where approx. 60% of values are 1, the remaining 0.
rbinom(n = N, size = 1, prob = 0.6)

# size = 3, prob = 0.5 counts how many heads you'd get if you flipped a fair count thrice (1/8 = 0, 3/8 = 1, 3/8 = 2, 1/8 = 3)
rbinom(n = N, size = 3, prob = 0.5)
```

### The poisson distribution
```{r}
rpois(n = N, lambda = 15)
```

### And whatever else

Read about other distributions using e.g., `?rnorm`, and notice the other ways of extracting info about a distribution (dnorm, pnorm, qnorm for the normal density function, cumulative distribution function and quantile function, respectively).

```{r}
?rweibull
?rcauchy
?rchisq
# ...
```

## An example dataset

The simple way:

```{r}
df <- data.frame(
  trt = rbinom(n = 5, size = 1, prob = 0.5),
  age = rnorm(n = 5, mean = 65, sd = 7) |> round(1),
  tte = rpois(n = 5, 15)
)
df |> gt::gt()
```

Tibbles allow you to build up columns sequentially; i.e. use info from one column in building the next:

```{r}
#| output: false
library(tibble)
```


```{r}
df_tibble <- tibble::tibble(
  trt = rbinom(n = 5, size = 1, prob = 0.5),
  age = rnorm(n = 5, mean = 65, sd = 7) |> round(1),
  tte_death = rpois(n = 5, lambda = 15+trt),
  tte_censor = rpois(n = 5, lambda = 13),
  tte = pmin(tte_death, tte_censor),
  event = ifelse(tte_death <= tte_censor, 1, 0)
)
df_tibble |> gt::gt()
```


## Sampling from a set of values

Sample from a vector (a form of *list* in R) of values, using `sample()`.

```{r}
vec <- c(1,5,8)
sample(
  x = vec,
  size = 10,
  replace = TRUE,
  prob = c(0.2,0.3,0.5)
)
```

This can also be used to sample row-indices to extract entire rows from a dataset.

```{r}
row_indices <- sample(
  x = 1:nrow(df_tibble),
  size = 3
)
row_indices

df_tibble[row_indices,] |> gt::gt()
```
Or use the `{dplyr}` function `sample_n()` to sample rows from a table directly:

```{r}
dplyr::sample_n(df_tibble, size = 3) |> gt::gt()
```


