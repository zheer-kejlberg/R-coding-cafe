[
  {
    "objectID": "practical-info.html",
    "href": "practical-info.html",
    "title": "ZKA",
    "section": "",
    "text": "Things to do before asking for help\nBeing proficient in R does not equate to sitting down and writing everything free-hand. Experienced R users search online and ask LLMs. The great thing about R is that there are often multiple solutions to a coding problem. What often separates an experienced user from a new user is that the experienced user knows what to search for and where. We suggest you search on StackOverflow; this can be daunting at first but is extremely helpful once you’ve learned to find your way around.\n\n\n\n\n\n\nCautionAI-tools\n\n\n\n\n\nAs a next step, it can be useful to use AI-tools like ChatGPT; however, beware that these can make up functions, that it often still requires debugging, and that even working solutions (especially to more complex questions) can be unstable over time or across datasets.\n\n\n\n\n\nAsking a clear coding question\nSome issues are simple; e.g., “I cannot download this package”. Other times what you want to do is more complex and needs context to explain to someone on the outside. Therefore, you need to prepare and provide the context to the person you are asking for help. This includes showing the structure of your dataset, presenting the functions you’ve used, and describing what you have tried so far.\n\n\n\n\n\n\nTipMinimal, reproducible examples\n\n\n\n\n\nThe first lesson in the coding café was specifically about preparing a good question (read the notes about minimal, reproducible examples).\n\n\n\n\n\nNote about sensitive data\n\n\n\n\n\n\nWarningIf you are working on DST\n\n\n\n\n\nyou are not allowed to show the data to anyone else! This is your own responsibility, and the helpers will not check what platform you’re working on.\n\n\n\nYou may need to prepare your question a bit more. Still, the principles of the minimal, reproducible example apply."
  },
  {
    "objectID": "notes/lesson-notes/01-Minimal-Reproducible-Example.html",
    "href": "notes/lesson-notes/01-Minimal-Reproducible-Example.html",
    "title": "Minimal, reproducible example",
    "section": "",
    "text": "Consider StackOverflow! Always look for extisting answers to your question first, then post! AI (LLMs) can be a good help for simple cases but for more complex things will often give you code that breaks easily. Can also at times be esoteric and difficult to debug.\nThere is no shame in using LLMs as long as one is aware of these issues. In fact, LLMs can be a great way of turning your headache into a well-formed question.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Minimal, reproducible example"
    ]
  },
  {
    "objectID": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#setting-the-random-seed",
    "href": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#setting-the-random-seed",
    "title": "Minimal, reproducible example",
    "section": "Setting the random seed",
    "text": "Setting the random seed\nBefore doing any random operations, setting the seed to a fixed value will ensure that the code produces exactly the same output every time:\n\nset.seed(12345)\nrpois(5, 10)\n\n[1] 11 12  9  8 11\n\nset.seed(12345)\nrpois(5, 10) \n\n[1] 11 12  9  8 11\n\nset.seed(23)\nrpois(5, 10)\n\n[1] 10  8 12 15 13",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Minimal, reproducible example"
    ]
  },
  {
    "objectID": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#sampling-from-a-distribution",
    "href": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#sampling-from-a-distribution",
    "title": "Minimal, reproducible example",
    "section": "Sampling from a distribution",
    "text": "Sampling from a distribution\n\nN &lt;- 20\n\n\nThe normal distribution\n\n# The normal distribution\nrnorm(n = N, mean = 65, sd = 7)\n\n [1] 72.75243 63.05340 72.13444 65.31806 76.03046 66.52802 57.67425 62.97918\n [9] 68.37085 56.48537 67.15696 61.35875 61.90380 60.80481 74.06204 70.84774\n[17] 61.03789 70.51894 56.83849 61.28426\n\n\n\n\nThe binomial distribution\n\n# size = number of flips of the coin. E.g., size=1 and prob = 0.3 gives you a binary variable, where approx. 60% of values are 1, the remaining 0.\nrbinom(n = N, size = 1, prob = 0.6)\n\n [1] 1 0 1 0 0 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0\n\n# size = 3, prob = 0.5 counts how many heads you'd get if you flipped a fair count thrice (1/8 = 0, 3/8 = 1, 3/8 = 2, 1/8 = 3)\nrbinom(n = N, size = 3, prob = 0.5)\n\n [1] 2 2 3 2 0 1 2 1 2 3 2 0 3 2 2 0 1 3 0 1\n\n\n\n\nThe poisson distribution\n\nrpois(n = N, lambda = 15)\n\n [1]  8 15 13 15 10 14  7 17 13 15 15 16 13 16 18 12 15 22 10 16\n\n\n\n\nAnd whatever else\nRead about other distributions using e.g., ?rnorm, and notice the other ways of extracting info about a distribution (dnorm, pnorm, qnorm for the normal density function, cumulative distribution function and quantile function, respectively).\n\n?rweibull\n?rcauchy\n?rchisq\n# ...",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Minimal, reproducible example"
    ]
  },
  {
    "objectID": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#an-example-dataset",
    "href": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#an-example-dataset",
    "title": "Minimal, reproducible example",
    "section": "An example dataset",
    "text": "An example dataset\nThe simple way:\n\ndf &lt;- data.frame(\n  trt = rbinom(n = 5, size = 1, prob = 0.5),\n  age = rnorm(n = 5, mean = 65, sd = 7) |&gt; round(1),\n  tte = rpois(n = 5, 15)\n)\ndf |&gt; gt::gt()\n\n\n\n\n\n\n\ntrt\nage\ntte\n\n\n\n\n0\n70.1\n16\n\n\n1\n62.0\n19\n\n\n1\n64.1\n20\n\n\n0\n72.2\n18\n\n\n0\n65.0\n14\n\n\n\n\n\n\n\nTibbles allow you to build up columns sequentially; i.e. use info from one column in building the next:\n\nlibrary(tibble)\n\n\ndf_tibble &lt;- tibble::tibble(\n  trt = rbinom(n = 5, size = 1, prob = 0.5),\n  age = rnorm(n = 5, mean = 65, sd = 7) |&gt; round(1),\n  tte_death = rpois(n = 5, lambda = 15+trt),\n  tte_censor = rpois(n = 5, lambda = 13),\n  tte = pmin(tte_death, tte_censor),\n  event = ifelse(tte_death &lt;= tte_censor, 1, 0)\n)\ndf_tibble |&gt; gt::gt()\n\n\n\n\n\n\n\ntrt\nage\ntte_death\ntte_censor\ntte\nevent\n\n\n\n\n0\n69.8\n13\n14\n13\n1\n\n\n0\n74.4\n13\n16\n13\n1\n\n\n1\n76.8\n12\n6\n6\n0\n\n\n0\n69.4\n17\n14\n14\n0\n\n\n0\n57.9\n17\n11\n11\n0",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Minimal, reproducible example"
    ]
  },
  {
    "objectID": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#sampling-from-a-set-of-values",
    "href": "notes/lesson-notes/01-Minimal-Reproducible-Example.html#sampling-from-a-set-of-values",
    "title": "Minimal, reproducible example",
    "section": "Sampling from a set of values",
    "text": "Sampling from a set of values\nSample from a vector (a form of list in R) of values, using sample().\n\nvec &lt;- c(1,5,8)\nsample(\n  x = vec,\n  size = 10,\n  replace = TRUE,\n  prob = c(0.2,0.3,0.5)\n)\n\n [1] 5 5 8 5 8 8 5 5 8 8\n\n\nThis can also be used to sample row-indices to extract entire rows from a dataset.\n\nrow_indices &lt;- sample(\n  x = 1:nrow(df_tibble),\n  size = 3\n)\nrow_indices\n\n[1] 2 4 5\n\ndf_tibble[row_indices,] |&gt; gt::gt()\n\n\n\n\n\n\n\ntrt\nage\ntte_death\ntte_censor\ntte\nevent\n\n\n\n\n0\n74.4\n13\n16\n13\n1\n\n\n0\n69.4\n17\n14\n14\n0\n\n\n0\n57.9\n17\n11\n11\n0\n\n\n\n\n\n\n\nOr use the {dplyr} function sample_n() to sample rows from a table directly:\n\ndplyr::sample_n(df_tibble, size = 3) |&gt; gt::gt()\n\n\n\n\n\n\n\ntrt\nage\ntte_death\ntte_censor\ntte\nevent\n\n\n\n\n0\n57.9\n17\n11\n11\n0\n\n\n0\n69.4\n17\n14\n14\n0\n\n\n0\n74.4\n13\n16\n13\n1",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Minimal, reproducible example"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html",
    "href": "notes/lesson-notes/02-Debugging.html",
    "title": "Writing working code—and debugging it",
    "section": "",
    "text": "# Get started\nset.seed(1234)\nlibrary(dplyr)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#two-important-error-messages",
    "href": "notes/lesson-notes/02-Debugging.html#two-important-error-messages",
    "title": "Writing working code—and debugging it",
    "section": "Two important error messages",
    "text": "Two important error messages\n\n&gt; Error in [insert some code] : ! argument is of length zero\n\nx &lt;- c(1, 2, 3)\n\nx[0]\n\nnumeric(0)\n\nif (x[0]&gt;2) print(x)\n\nError in `if (x[0] &gt; 2) ...`:\n! argument is of length zero\n\n\nThis means that some object you tried to work with was empty; it simply didn’t exist as you thought or didn’t contain anything. In the above case, the vector x does not have an “index 0” to subset (fun fact: in most other languages, the first position of a list-like object is position 0).\n\n\n&gt; object of type ‘closure’ is not subsettable\n\nprinter &lt;- data.frame(size = c(1, 2, 3), color = c(\"red\", \"orange\", \"blue\"))\nprinter[1,] # works fine\n\n  size color\n1    1   red\n\nprint[1,] # the print function is the here object of type 'closure'\n\nError in `print[1, ]`:\n! object of type 'closure' is not subsettable\n\n\nYou wanted to subset an object, but you accidentally tried to subset a function; in this case, the print() function.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#first-steps-when-encountering-an-error-message",
    "href": "notes/lesson-notes/02-Debugging.html#first-steps-when-encountering-an-error-message",
    "title": "Writing working code—and debugging it",
    "section": "First steps when encountering an error message",
    "text": "First steps when encountering an error message\nCheck the error message carefully! Sometimes the error message tells you which file and line number the error occurred on.\n\nLook it up\n\nStackOverflow.com\nList of common errors and warnings\n\nHave you tried a fresh session?\n\n\nDebugging and sanity checks - useful before errors even occur\n\nUse the scientific method\nGo through everything - line by line. For each segment of code, form hypotheses as to what the output for a given input should be. This might quickly prove you wrong and expose disagreement between code purpose and function.\n\n\nPrint debugging\nCheck intermediate results.\nUse some of the following summary functions for data structure and content:\n\n# Let's look at the mtcars dataset (and add our own categorical variable with some NAs, for good measure)\nmtcars &lt;- mtcars |&gt; \n  mutate(col = sample(c(\"orange\", \"blue\", \"white\", NA_character_),\n                      size=nrow(mtcars), \n                      replace=T)\n         )\n\nmtcars |&gt; head(4) |&gt; gt::gt()\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\ncol\n\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\nNA\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\nNA\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\nblue\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\nblue\n\n\n\n\n\n\n\n\n\n\nCheck for NAs\nAlways a good place to start. NAs are where good intentions in data management go to die. Make sure you always know how many NAs there are—and how many there should be.\n\n# Check if NA - get a vector of TRUE/FALSE values, one for each row of the data in column 'col':\nis.na(mtcars$col) \n\n [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[25]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE\n\n# Get total number of NAs in the column:\nis.na(mtcars$col) |&gt; sum()\n\n[1] 13\n\n\n\n\n\n\nSummarise a dataset\nLet’s now get summary data for every variable in the dataset.\n\n# Summarise data\nmtcars |&gt; select(c(mpg, vs, col)) |&gt; summary()\n\n      mpg              vs             col           \n Min.   :10.40   Min.   :0.0000   Length:32         \n 1st Qu.:15.43   1st Qu.:0.0000   Class :character  \n Median :19.20   Median :0.0000   Mode  :character  \n Mean   :20.09   Mean   :0.4375                     \n 3rd Qu.:22.80   3rd Qu.:1.0000                     \n Max.   :33.90   Max.   :1.0000                     \n\n\nWhile summary() provides a decent overview, the describe() function from Harrell’s {Hmisc} package is far more detailed.\n\nmtcars |&gt; select(c(mpg, vs, col)) |&gt; Hmisc::describe()\n\nselect(mtcars, c(mpg, vs, col)) \n\n 3  Variables      32  Observations\n--------------------------------------------------------------------------------\nmpg \n       n  missing distinct     Info     Mean  pMedian      Gmd      .05 \n      32        0       25    0.999    20.09     19.6    6.796    12.00 \n     .10      .25      .50      .75      .90      .95 \n   14.34    15.43    19.20    22.80    30.09    31.30 \n\nlowest : 10.4 13.3 14.3 14.7 15  , highest: 26   27.3 30.4 32.4 33.9\n--------------------------------------------------------------------------------\nvs \n       n  missing distinct     Info      Sum     Mean \n      32        0        2    0.739       14   0.4375 \n\n--------------------------------------------------------------------------------\ncol \n       n  missing distinct \n      19       13        3 \n                               \nValue        blue orange  white\nFrequency      11      4      4\nProportion  0.579  0.211  0.211\n--------------------------------------------------------------------------------\n\n\n\n\n\n\nRelations among variables\nNow we’ll turn our attention to looking at relations among multiple variables. A simply way is to form a contingency table (a 2x2 or, for categories with &gt;2 levels, a pxq table) using table():\n\nwith(mtcars, table(cyl, gear))\n\n   gear\ncyl  3  4  5\n  4  1  8  2\n  6  2  4  1\n  8 12  0  2\n\n\n\n\n\n\nsummarise()\nsummarise() from {dplyr} creates a new dataset with variables calculated within whatever groups were provided (note: this does not retain anything else in the dataset)\n\nmtcars |&gt; group_by(cyl) |&gt; dplyr::summarise(mpg_min = min(mpg, na.rm=T), \n                                            mpg_Q1 = quantile(mpg, 0.25),\n                                            mpg_median = median(mpg, na.rm=T),\n                                            mpg_Q3 = quantile(mpg, 0.75),\n                                            mpg_max = max(mpg, na.rm=T),\n                                            col_NAs = sum(is.na(col))\n                                            )\n\n# A tibble: 3 × 7\n    cyl mpg_min mpg_Q1 mpg_median mpg_Q3 mpg_max col_NAs\n  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;\n1     4    21.4   22.8       26     30.4    33.9       4\n2     6    17.8   18.6       19.7   21      21.4       5\n3     8    10.4   14.4       15.2   16.2    19.2       4\n\n\n\n\n\n\nMake a Table1\nFinally, sometimes it’s nice to just get a full overview of the data, as it will look in a Table1:\n\nmtcars |&gt; select(c(mpg, cyl, disp, col)) |&gt;\n  gtsummary::tbl_summary(by = cyl,\n                         statistic = list(mpg ~ \"{mean} (SD: {sd})\"),\n                         missing_text = \"Missing\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\n4\nN = 111\n6\nN = 71\n8\nN = 141\n\n\n\n\nmpg\n26.7 (SD: 4.5)\n19.7 (SD: 1.5)\n15.1 (SD: 2.6)\n\n\ndisp\n108 (79, 121)\n168 (160, 225)\n351 (301, 400)\n\n\ncol\n\n\n\n\n\n\n\n\n    blue\n3 (43%)\n2 (100%)\n6 (60%)\n\n\n    orange\n3 (43%)\n0 (0%)\n1 (10%)\n\n\n    white\n1 (14%)\n0 (0%)\n3 (30%)\n\n\n    Missing\n4\n5\n4\n\n\n\n1 Mean (SD: SD); Median (Q1, Q3); n (%)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#advanced-functionality-when-you-see-an-error",
    "href": "notes/lesson-notes/02-Debugging.html#advanced-functionality-when-you-see-an-error",
    "title": "Writing working code—and debugging it",
    "section": "Advanced functionality: when you see an error",
    "text": "Advanced functionality: when you see an error\n\nThe call tree\nHere’s some code. The functions are irrelevant, expect make_df() takes an input, passes something on to pass_on_df(), which (conditionally) calls the return_error() function. When you use make_df(), you might not realise all of this is happening behind the scenes.\n\nmake_df &lt;- function(x) {\n  df &lt;- data.frame(y=x+10)\n  pass_on_df(df)\n}\n\npass_on_df &lt;- function(x) {\n  # ...\n  if(x$y &gt; 11) return_error(x$y)\n}\n\nreturn_error &lt;- function(x) {\n  stop(paste0(x, \" not valid input\"))\n}\n\nmake_df(10)\n\nError in `return_error()`:\n! 20 not valid input\n\n\nWhen you see this error in RStudio, it looks as follows:\n\nIf you click “Show Traceback” on the right, you’ll see:\n From bottom to top, you can see the order in which functions were called, until the error occurred. Now you know it wasn’t make_df() directly but rather something downstream called pass_on_df(). This may not always give an obvious solution, but at least it can help you find out which package/function you should be Googling to understand the error message.\n\n\nFormal debugging tools\nBelow are a few highly related functions that can be useful for debugging. Sometimes you’ll see a button to “Rerun with Debug” right under the “Show Traceback” button we just discussed. Doing so sends you inside the working environment (‘the scope’) of the functions to “see what they see”. I.e., you see the data you put into the functions, and how these were manipulated at each step right until the error occurred. This can help reveal the cause.\n\nbrowser()\nUsing this gives a similar experience; if you wrote a function yourself, you can write browser() anywhere within it to force a break in execution. It then allows you to inspect your function’s inner workings (and contents) up to and at that point.\n\n\ndebug()\nthis is useful for inspecting other people’s functions; it adds a “browser()” statement into another function for you (undebug() removes it)\n\n\nbreakpoints\nIn .R scripts, you can click to the left of the line-numbers to add a small red dot. This is like inserting a browser() statement there.\n\n\ntrace() / untrace()\nLike debug() but can be used to insert any other code of your choosing into a function.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#warnings",
    "href": "notes/lesson-notes/02-Debugging.html#warnings",
    "title": "Writing working code—and debugging it",
    "section": "Warnings",
    "text": "Warnings\nWarnings are messages that don’t prevent your code from running. Treat these as you would errors, until you’re sure they’re harmless.\nBecause your code runs, they can be easy to miss; but usually they’re a package author’s way of letting you know you might not be using their package in the way it was intended;\nThey sometimes mean something horrible happened",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#preparing-for-errors",
    "href": "notes/lesson-notes/02-Debugging.html#preparing-for-errors",
    "title": "Writing working code—and debugging it",
    "section": "Preparing for errors",
    "text": "Preparing for errors\ntry() is handy when you know some code can cause an error but you don’t want it to break everything; you want to just skip over it in that case:\n\nlog_ &lt;- function(x) {\n  try(\n    return(log(x)),\n    silent=TRUE\n  )\n  x\n}\n\n\nlog_(2)\n\n[1] 0.6931472\n\nlog_(1)\n\n[1] 0\n\nlog_(0)\n\n[1] -Inf\n\nlog_(\"a\")\n\n[1] \"a\"\n\n\nThis function takes any input and tries to take its log; if unsuccessful, it simply returns the input unchanged (yes, I know this is a dumb function).",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#when-code-runs-forever",
    "href": "notes/lesson-notes/02-Debugging.html#when-code-runs-forever",
    "title": "Writing working code—and debugging it",
    "section": "When code runs forever",
    "text": "When code runs forever\n\nR code\n\nIf R never stops evaluting (e.g., stuck in an infinite loop), you can manually stop the process. This can be frustrating as you’re left with little idea of what went wrong.\n\nCompiled code\n\nIf R creashes the moment you hit “Interrupt R”, the code was probably being run in another language (C/C++). There’s no way out but to restart and get to debugging.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/lesson-notes/02-Debugging.html#more-reading",
    "href": "notes/lesson-notes/02-Debugging.html#more-reading",
    "title": "Writing working code—and debugging it",
    "section": "More reading",
    "text": "More reading\nHadley Wickham’s tutorial on debugging",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Writing working code—and debugging it"
    ]
  },
  {
    "objectID": "notes/extra/index.html",
    "href": "notes/extra/index.html",
    "title": "Extra notes and tutorials",
    "section": "",
    "text": "This section will contain miscellaneous notes curated or written for other causes but which may be useful here as well.",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "General info",
    "section": "",
    "text": "We’re a bi-weekly open coding café for anyone working at Steno Aarhus (SDCA), Dept. of Endocrinology (HoK), AU-Public Health, AU-Clinical Medicine and AU-Biomedicine to come and get help with their code."
  },
  {
    "objectID": "index.html#format",
    "href": "index.html#format",
    "title": "General info",
    "section": "Format",
    "text": "Format\nBelow are the planned dates; you can arrive and leave at any time.\nThere will be a ~15 minute presentation at the beginning of each session, tackling a relevant topic (a general R concept, workflows, helpful packages, etc.)\nSubsequently, 1-2 experienced instructors will help with your specific challenges and questions. But please interact with each other—maybe someone in the group has the solution to your exact problem.\n\n\n\n\n\n\nTipPrerequisites\n\n\n\n\n\nYou’re expected to have an introductory knowledge of R and RStudio; consider\n\na course such as this offered by the Danish Diabetes and Endocrinology Academy\nan online course such as this one at Datacamp.com\nthe fantastic online book R for Data Science"
  },
  {
    "objectID": "index.html#schedule-and-themes",
    "href": "index.html#schedule-and-themes",
    "title": "General info",
    "section": "Schedule and themes",
    "text": "Schedule and themes\n\n\n\n\n\n\nNotePrevious sessions (and notes)\n\n\n\n\n\n\n\n\n\n\n\n\n\nDates, times, locations, and lesson topics.\n\n\n \n\n\n\nWeek\nTime\nLocation\nTopic\nPresenter\nHelpers\n\n\n\n\nTue, Jan 13, 2026\n03\n10:00-12:00\nHjørnerummet (A401-109)\nIntroduction and planning of format  \nZheer\n-\n\n\nTue, Jan 27, 2026\n05\n10:00-11:30\nHjørnerummet (A401-109)\nHow to ask for help: The minimal reproducible example and making simulated data (notes)\nZheer\n-\n\n\nWed, Feb 18, 2026\n08\n10:00-11:30\nHjørnerummet (A401-109)\nPrevention and diagnosis of errors in R (notes)\nZheer\n-\n\n\nTue, Feb 24, 2026\n09\n10:00-11:30\nHjørnerummet (A401-109)\nTypes of data (object, classes) (notes)\nZheer\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpcoming sessions\nAdd to your calendar to receive automatic updates.\nJoin future sessions in person or via the Zoom link\n\n\n\n\n\n\n\n\nDates, times, locations, and lesson topics\n\n\nNote, the schedule may be subject to change\n\n\n\nWeek\nTime\nLocation\nTopic\nPresenter\nHelpers\n\n\n\n\nTue, Mar 10, 2026\n11\n10:00-11:30\nHjørnerummet (A401-109)\nWriting functions instead of copy/paste\nZheer\n-\n\n\nTue, Mar 24, 2026\n13\n10:00-11:30\nHjørnerummet (A401-109)\nLoops, recursion, parallelisation\nZheer\n-\n\n\nTue, Apr 7, 2026\n15\n10:00-11:30\nHjørnerummet (A401-109)\nParadigms: Base R vs. Tidyverse vs. data.table\nZheer\n-\n\n\nTue, Apr 21, 2026\n17\n10:00-11:30\nHjørnerummet (A401-109)\nMore tidyverse\nZheer\n-\n\n\nTue, May 5, 2026\n19\n10:00-11:30\nHjørnerummet (A401-109)\nHandling many packages—and cross-package workflows\nZheer\n-\n\n\nTue, May 19, 2026\n21\n10:00-11:30\nHjørnerummet (A401-109)\nMoving between R and Stata\nZheer\n-\n\n\nTue, Jun 2, 2026\n23\n10:00-11:30\nHjørnerummet (A401-109)\nMarkdown basics: Using Quarto and Rmarkdown\nZheer\n-\n\n\nTue, Jun 16, 2026\n25\n10:00-11:30\nHjørnerummet (A401-109)\nDatabase formats (parquet and more)\nZheer\n-\n\n\n\n\n\nIntermezzo\n\n\n\n\n\nTue, Aug 11, 2026\n33\n10:00-11:30\n\nTBA\n\n\n\n\n\n\n\n\n\n\n\nOther planned topics are:\n\nPublication-ready plots with the grammar of graphics: {ggplot2} and {patchwork}\nInteractive dashboards: {shiny}, {bslib}, {ggvis}\nNice-to-know packages\n\nData cleaning: {janitor}\nData summaries: {Hmisc}, {skimr}\nData presentation: {tinytable}, {kable}, {gt}, {gtsummary}\n\nMatching and Weighting (using {MatchIt} and {WeightIt} packages)\nMissing data: relevant packages, including imputation via {mice} and combining this with {MatchThem}/{WeightThem}\nSurvival analysis: {Epi}, {survival}, {ggsurvfit}\nPreregistration as a means to improved workflows in R\nWorking with AI/LLMs (large language models)—the right way\nReproducible pipelines: {renv}, {targets}\n\nReach out to me if you want anything added to the list.\n\n\n\nThis website was made in Quarto: see how here"
  },
  {
    "objectID": "notes/extra/1-example-pipeline.html",
    "href": "notes/extra/1-example-pipeline.html",
    "title": "Example pipeline",
    "section": "",
    "text": "Below I will construct some DST-like datasets and show how a full data preprocessing pipeline might look.\n\nset.seed(123456)\nlibrary(dplyr)",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials",
      "Example pipeline"
    ]
  },
  {
    "objectID": "notes/extra/1-example-pipeline.html#working-with-data-from-statistics-denmark-dst",
    "href": "notes/extra/1-example-pipeline.html#working-with-data-from-statistics-denmark-dst",
    "title": "Example pipeline",
    "section": "",
    "text": "Below I will construct some DST-like datasets and show how a full data preprocessing pipeline might look.\n\nset.seed(123456)\nlibrary(dplyr)",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials",
      "Example pipeline"
    ]
  },
  {
    "objectID": "notes/extra/1-example-pipeline.html#lets-construct-some-fake-data",
    "href": "notes/extra/1-example-pipeline.html#lets-construct-some-fake-data",
    "title": "Example pipeline",
    "section": "Let’s construct some fake data",
    "text": "Let’s construct some fake data\n\nPopulation\n\nn &lt;- 2000\nbef &lt;- data.frame(\n  PNR = runif(n, min = 1e6, max = 1e7-1) |&gt; floor() |&gt; as.character(),\n  koen = rbinom(n, size = 1, prob = 0.49) + 1,\n  FOED_DAG = runif(n, as.Date(\"1940-01-01\"), as.Date(\"1959-12-31\")) |&gt; floor()  |&gt; as.Date()\n)\n\nPreview:\n\nbef |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nkoen\nFOED_DAG\n\n\n\n\n8180058\n2\n1955-09-19\n\n\n7782085\n2\n1947-06-21\n\n\n4521300\n1\n1959-04-11\n\n\n\n\n\n\n\n\n\nLMDB\n\n# Making an API call to a website that sends back all existing ATC-codes + corresponding drug names.\nATC_codes &lt;- httr2::request(\"https://pgx-db.org/rest-api/atc/atc_code/CS/\") |&gt;\n  httr2::req_headers(\n    accept = \"application/json\",\n    `X-CSRFToken`= \"3T14DJ7uB6gqdVnsbPclbAonNeAAiP4rAA47TXe3lsagl9PGOlPM9BKNhIFughWy\"\n  ) |&gt;\n  httr2::req_perform() |&gt;\n  httr2::resp_body_json() |&gt; \n  dplyr::bind_rows()\n\n# Select a subset\nATC_select_glucose_lowering &lt;- ATC_codes |&gt; \n  rename(ATC = `ATC code`) |&gt;\n  filter(grepl(\"^A10BA02|^A10BB12|^A10BH0[1,2,3]|^A10BJ0[2,6]|^A10BK0[1-4]\", ATC))\n\n# Simulate prescriptions\nn_lmdb &lt;- n * 10\nlmdb &lt;- sample_n(ATC_select_glucose_lowering,\n               size = n_lmdb,\n               replace=T) |&gt;\n  mutate(PNR = sample(bef$PNR, size = n_lmdb, replace=T),\n         EKSD = runif(n_lmdb, as.Date(\"2000-01-01\"), as.Date(\"2020-12-31\")) |&gt; floor()  |&gt; as.Date(),\n         APK = runif(n_lmdb, 1, 4) |&gt; floor(),\n         PACKSIZE = runif(n_lmdb, 1, 4) |&gt; floor() * 10,\n         STRNUM = round(rnorm(n_lmdb, 15, 4)),\n         VOLUME = PACKSIZE * APK)\n\nPreview:\n\nlmdb |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nATC\nDescription\nPNR\nEKSD\nAPK\nPACKSIZE\nSTRNUM\nVOLUME\n\n\n\n\nA10BB12\nGlimepiride\n8913161\n2010-04-16\n2\n20\n12\n40\n\n\nA10BJ06\nSemaglutide\n7155623\n2005-01-23\n3\n10\n19\n30\n\n\nA10BJ02\nLiraglutide\n2448276\n2005-03-13\n2\n20\n23\n40\n\n\n\n\n\n\n\n\n\nLPR2\n\nn_lpr &lt;- n * 30\nhip_injury_icd &lt;- c(\"S70.0\", \"S71.0\", \"S72.0\", \"S72.1\", \"S72.2\", \"S72.3\", \"S72.4\", \"S72.7\", \"S72.8\", \"S72.9\")\nlpr_adm &lt;- data.frame(\n  PNR = sample(bef$PNR, size = n_lpr, replace = T),\n  RECNUM = runif(n_lpr, min = 1e9, max = 1e10-1) |&gt; floor() |&gt; unique(),\n  D_INDDTO = runif(n_lpr, as.Date(\"2000-01-01\"), as.Date(\"2009-12-31\")) |&gt; floor() |&gt; as.Date(),\n  C_ADIAG = sample(hip_injury_icd, n_lpr, replace=T)\n)\n\nlpr_diag &lt;- lpr_adm |&gt; \n  select(RECNUM, C_ADIAG) |&gt;\n  rename(C_DIAG = C_ADIAG) |&gt;\n  mutate(C_DIAGTYPE = \"A\") |&gt;\n  # Add in a B-diagnosis for a third of people\n  rbind(\n    data.frame(\n      RECNUM = sample(lpr_adm$RECNUM, n_lpr/3),\n      C_DIAG = sample(hip_injury_icd, n_lpr/3, replace=T),\n      C_DIAGTYPE = \"B\"\n    )\n  )\n\nPreviews:\n\nlpr_subset &lt;- lpr_adm$RECNUM |&gt; head(3)\nlpr_adm |&gt; filter(RECNUM %in% lpr_subset) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nRECNUM\nD_INDDTO\nC_ADIAG\n\n\n\n\n7465102\n7161939417\n2003-03-07\nS72.4\n\n\n4352898\n3238130082\n2005-04-19\nS72.4\n\n\n3752898\n3030336058\n2009-03-18\nS72.1\n\n\n\n\n\n\nlpr_diag |&gt; filter(RECNUM %in% lpr_subset) |&gt; gt::gt()\n\n\n\n\n\n\n\nRECNUM\nC_DIAG\nC_DIAGTYPE\n\n\n\n\n7161939417\nS72.4\nA\n\n\n3238130082\nS72.4\nA\n\n\n3030336058\nS72.1\nA\n\n\n3030336058\nS72.8\nB\n\n\n\n\n\n\n\n\n\nLAB\n\nn_lab &lt;- n * 40\nn_lab_missing &lt;- floor(n / 10)\nlab_dm_forsker &lt;- data.frame(\n  PNR = sample(bef$PNR, size = n - n_lab_missing) |&gt; sample(size = n_lab, replace = T),\n  SAMPLINGDATE = runif(n_lab, as.Date(\"2000-01-01\"), as.Date(\"2009-12-31\")) |&gt; floor()  |&gt; as.Date(),\n  ANALYSISCODE = rep(\"eGFR\", n_lab)\n) |&gt;\n  left_join(bef |&gt; select(c(PNR, FOED_DAG)), by = \"PNR\") |&gt;\n  mutate(\n    VALUE = rnorm(n_lab, \n                  mean = 100 - as.numeric((as.Date(\"2000-01-01\") - as.Date(FOED_DAG))/3650)^10/(2^20) |&gt; round(2), \n                  sd = 10) |&gt; round()\n  ) |&gt;\n  select(-c(FOED_DAG))\n\nPreview:\n\nlab_dm_forsker |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nSAMPLINGDATE\nANALYSISCODE\nVALUE\n\n\n\n\n8172410\n2006-12-10\neGFR\n101\n\n\n2697955\n2004-02-22\neGFR\n38\n\n\n1088015\n2009-09-23\neGFR\n98",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials",
      "Example pipeline"
    ]
  },
  {
    "objectID": "notes/extra/1-example-pipeline.html#putting-things-together",
    "href": "notes/extra/1-example-pipeline.html#putting-things-together",
    "title": "Example pipeline",
    "section": "Putting things together",
    "text": "Putting things together\n\nIdentify first hip fracture\n\nlpr &lt;- left_join(lpr_adm, lpr_diag, by = \"RECNUM\") |&gt;\n  # Only care about A-diagnoses pertaining to hip fracture (S72...)\n  filter(C_DIAGTYPE == \"A\",\n         grepl(\"^S72\", C_DIAG)\n  ) |&gt;\n  # For each person, keep only first date\n  group_by(PNR) |&gt;\n  filter(D_INDDTO == min(D_INDDTO)) |&gt;\n  # Keep one row if multiple diagnoses on the same date\n  slice(1) |&gt;\n  ungroup() # Always best to ungroup in the end\n\nPreview:\n\nlpr |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nRECNUM\nD_INDDTO\nC_ADIAG\nC_DIAG\nC_DIAGTYPE\n\n\n\n\n1000746\n5843620927\n2000-05-07\nS72.0\nS72.0\nA\n\n\n1006023\n7507439271\n2000-01-03\nS72.1\nS72.1\nA\n\n\n1006164\n1399413324\n2000-04-04\nS72.0\nS72.0\nA\n\n\n\n\n\n\n\n\n\nAdd background info\n\npop &lt;- left_join(lpr, bef, by = \"PNR\") |&gt;\n  # calculate age in days, divide into years, round to two decimals\n  mutate(age = ((D_INDDTO - FOED_DAG) / 365.25) |&gt; as.numeric() |&gt; round(2)) |&gt;\n  select(c(PNR, D_INDDTO, FOED_DAG, koen, age)) |&gt;\n  rename(index_date = D_INDDTO)\n\nPreview:\n\npop |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nindex_date\nFOED_DAG\nkoen\nage\n\n\n\n\n1000746\n2000-05-07\n1947-04-20\n1\n53.05\n\n\n1006023\n2000-01-03\n1957-02-07\n1\n42.90\n\n\n1006164\n2000-04-04\n1947-04-19\n2\n52.96\n\n\n\n\n\n\n\n\n\nGet last eGFR before fracture\n\nlast_eGFR &lt;- left_join(pop, lab_dm_forsker, by = \"PNR\")\n# Note, approx 10% of individuals have never had an eGFR measured; they now have NAs\n\nlast_eGFR &lt;- last_eGFR |&gt;\n  # Get eGFRs prior to fracture\n  filter(SAMPLINGDATE &lt;= index_date) |&gt;\n  # keep only last eGFR for each person\n  group_by(PNR) |&gt;\n  filter(SAMPLINGDATE == max(SAMPLINGDATE)) |&gt;\n  slice(1) |&gt;\n  ungroup() |&gt;\n  # keep only necessary columns to add back onto the full pop\n  select(c(PNR, SAMPLINGDATE, VALUE)) |&gt;\n  rename(eGFR_val = VALUE, eGFR_date = SAMPLINGDATE)\n\npop &lt;- left_join(pop, last_eGFR, by =\"PNR\")\n\nPreviews:\n\nlast_eGFR |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\neGFR_date\neGFR_val\n\n\n\n\n1000746\n2000-04-19\n80\n\n\n1010815\n2000-01-17\n107\n\n\n1019932\n2001-03-12\n107\n\n\n\n\n\n\npop |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nindex_date\nFOED_DAG\nkoen\nage\neGFR_date\neGFR_val\n\n\n\n\n1000746\n2000-05-07\n1947-04-20\n1\n53.05\n2000-04-19\n80\n\n\n1006023\n2000-01-03\n1957-02-07\n1\n42.90\nNA\nNA\n\n\n1006164\n2000-04-04\n1947-04-19\n2\n52.96\nNA\nNA\n\n\n\n\n\n\n\n\n\nGet first glucose-lowering drug prescription\n\nlmdb_first_gld &lt;- lmdb |&gt;\n  # For each person, only keep the earliest date of redemption\n  group_by(PNR) |&gt;\n  filter(EKSD == min(EKSD)) |&gt;\n  # keep one line per person\n  slice(1) |&gt;\n  ungroup() |&gt;\n  select(c(PNR, EKSD))\n\nPreview:\n\nlmdb_first_gld |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nEKSD\n\n\n\n\n1000746\n2000-12-27\n\n\n1006023\n2000-07-12\n\n\n1006164\n2000-11-09\n\n\n\n\n\n\n\n\n\nAdd in medication data and remove individuals with prior drug exposure\n\npop &lt;- left_join(pop, lmdb_first_gld, by =\"PNR\")\n\n# Only keep people with no prior glucose-lowering drug use before hip fracture\npop &lt;- pop |&gt;\n  filter(is.na(EKSD) | index_date &lt;= EKSD) |&gt;\n  select(-c(EKSD))\n\nPreview:\n\npop |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nindex_date\nFOED_DAG\nkoen\nage\neGFR_date\neGFR_val\n\n\n\n\n1000746\n2000-05-07\n1947-04-20\n1\n53.05\n2000-04-19\n80\n\n\n1006023\n2000-01-03\n1957-02-07\n1\n42.90\nNA\nNA\n\n\n1006164\n2000-04-04\n1947-04-19\n2\n52.96\nNA\nNA\n\n\n\n\n\n\n\n\n\nGet first metformin prescription\n\nlmdb_metformin &lt;- lmdb |&gt;\n  filter(ATC == \"A10BA02\")\n\nlmdb_metformin &lt;- lmdb_metformin |&gt;\n  # For each person, only keep the earliest date of redemption\n  group_by(PNR) |&gt;\n  filter(EKSD == min(EKSD)) |&gt;\n  # For each prescription, multiply the pill dosage by the number of pills to get a total dose and sum it over all prescriptions for that date (in case of multiple redemptions same day) to get a grand total\n  mutate(no_of_pills = sum(APK * PACKSIZE),\n         total_dose = sum(APK * PACKSIZE * STRNUM)) |&gt;\n  # keep one line per person\n  slice(1) |&gt;\n  ungroup() |&gt;\n  select(c(PNR, EKSD, no_of_pills, total_dose)) |&gt;\n  rename(metf_date = EKSD,\n         metf_no_of_pills = no_of_pills,\n         metf_total_dose = total_dose)\n\nPreview:\n\nlmdb_metformin |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nmetf_date\nmetf_no_of_pills\nmetf_total_dose\n\n\n\n\n1010815\n2005-07-08\n30\n360\n\n\n1019932\n2001-02-20\n60\n840\n\n\n1024746\n2019-11-14\n30\n540\n\n\n\n\n\n\n\n\n\nAdd in metformin data\n\npop &lt;- left_join(pop, lmdb_metformin, by =\"PNR\")\n\nPreview:\n\npop |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nindex_date\nFOED_DAG\nkoen\nage\neGFR_date\neGFR_val\nmetf_date\nmetf_no_of_pills\nmetf_total_dose\n\n\n\n\n1000746\n2000-05-07\n1947-04-20\n1\n53.05\n2000-04-19\n80\nNA\nNA\nNA\n\n\n1006023\n2000-01-03\n1957-02-07\n1\n42.90\nNA\nNA\nNA\nNA\nNA\n\n\n1006164\n2000-04-04\n1947-04-19\n2\n52.96\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\n\n\n\n\nCalculate time to metformin\n\npop &lt;- pop |&gt;\n  mutate(tte_metf = difftime(metf_date, index_date))\n\nPreview:\n\npop |&gt; head(3) |&gt; gt::gt()\n\n\n\n\n\n\n\nPNR\nindex_date\nFOED_DAG\nkoen\nage\neGFR_date\neGFR_val\nmetf_date\nmetf_no_of_pills\nmetf_total_dose\ntte_metf\n\n\n\n\n1000746\n2000-05-07\n1947-04-20\n1\n53.05\n2000-04-19\n80\nNA\nNA\nNA\nNA\n\n\n1006023\n2000-01-03\n1957-02-07\n1\n42.90\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n1006164\n2000-04-04\n1947-04-19\n2\n52.96\nNA\nNA\nNA\nNA\nNA\nNA",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials",
      "Example pipeline"
    ]
  },
  {
    "objectID": "notes/extra/1-example-pipeline.html#now-you-can-start-analysing-the-data",
    "href": "notes/extra/1-example-pipeline.html#now-you-can-start-analysing-the-data",
    "title": "Example pipeline",
    "section": "Now you can start analysing the data…",
    "text": "Now you can start analysing the data…\n\nlibrary(ggplot2)\nggplot(pop, aes(x=age, y = eGFR_val)) +\n  geom_point() +\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3)) +\n  theme_bw()\n\nWarning: Removed 750 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 750 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "R Coding Café",
      "Extra notes and tutorials",
      "Example pipeline"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html",
    "href": "notes/lesson-notes/03-Data-Types.html",
    "title": "Data types and structures",
    "section": "",
    "text": "library(dplyr)\nlibrary(ggplot2)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#numerics",
    "href": "notes/lesson-notes/03-Data-Types.html#numerics",
    "title": "Data types and structures",
    "section": "Numerics",
    "text": "Numerics\nIntegers\n\nx &lt;- 1L\n\ntypeof(1:5)\n\n[1] \"integer\"\n\nclass(1L)\n\n[1] \"integer\"\n\n\nDoubles\n\nx &lt;- 1.3\n\ntypeof(x)\n\n[1] \"double\"\n\nclass(x)\n\n[1] \"numeric\"\n\n\nHowever, both can be seen as instances of numeric:\n\nis.numeric(1L)\n\n[1] TRUE\n\nis.numeric(1.3)\n\n[1] TRUE",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#complex",
    "href": "notes/lesson-notes/03-Data-Types.html#complex",
    "title": "Data types and structures",
    "section": "Complex",
    "text": "Complex\n\n6i\n\n[1] 0+6i\n\ntypeof(6i)\n\n[1] \"complex\"",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#character",
    "href": "notes/lesson-notes/03-Data-Types.html#character",
    "title": "Data types and structures",
    "section": "Character",
    "text": "Character\n\n\"Hello\"\n\n[1] \"Hello\"\n\ntypeof(\"Hello\")\n\n[1] \"character\"",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#logical",
    "href": "notes/lesson-notes/03-Data-Types.html#logical",
    "title": "Data types and structures",
    "section": "Logical",
    "text": "Logical\n\nTRUE\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nNA\n\n[1] NA\n\ntypeof(c(T,F,NA))\n\n[1] \"logical\"",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#raw",
    "href": "notes/lesson-notes/03-Data-Types.html#raw",
    "title": "Data types and structures",
    "section": "Raw",
    "text": "Raw\n\n\"Hello\" |&gt; charToRaw()\n\n[1] 48 65 6c 6c 6f\n\n\"Hello\" |&gt; charToRaw() |&gt; rawToBits()\n\n [1] 00 00 00 01 00 00 01 00 01 00 01 00 00 01 01 00 00 00 01 01 00 01 01 00 00\n[26] 00 01 01 00 01 01 00 01 01 01 01 00 01 01 00\n\n8 |&gt; intToBits()\n\n [1] 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[26] 00 00 00 00 00 00 00",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#numeric-vector",
    "href": "notes/lesson-notes/03-Data-Types.html#numeric-vector",
    "title": "Data types and structures",
    "section": "Numeric vector:",
    "text": "Numeric vector:\n\nc(1,3,4,2)\n\n[1] 1 3 4 2",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#character-vector",
    "href": "notes/lesson-notes/03-Data-Types.html#character-vector",
    "title": "Data types and structures",
    "section": "Character vector:",
    "text": "Character vector:\n\nc(\"Word1\", \"Word2\", \"Word3\")\n\n[1] \"Word1\" \"Word2\" \"Word3\"",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#logical-vector",
    "href": "notes/lesson-notes/03-Data-Types.html#logical-vector",
    "title": "Data types and structures",
    "section": "Logical vector:",
    "text": "Logical vector:\n\nc(TRUE, FALSE, TRUE, NA)\n\n[1]  TRUE FALSE  TRUE    NA",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#empty-vector",
    "href": "notes/lesson-notes/03-Data-Types.html#empty-vector",
    "title": "Data types and structures",
    "section": "Empty vector:",
    "text": "Empty vector:\n\nc(TRUE, FALSE)[0]\n\nlogical(0)\n\nc(\"hello\", \"world\")[0]\n\ncharacter(0)\n\nc(1.0, 2.3)[0]\n\nnumeric(0)\n\nc(1L, 4L)[0]\n\ninteger(0)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#actually-it-was-all-vectors-all-along",
    "href": "notes/lesson-notes/03-Data-Types.html#actually-it-was-all-vectors-all-along",
    "title": "Data types and structures",
    "section": "Actually, it was all vectors all along:",
    "text": "Actually, it was all vectors all along:\n\nc(1) == 1\n\n[1] TRUE",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#type-coercion",
    "href": "notes/lesson-notes/03-Data-Types.html#type-coercion",
    "title": "Data types and structures",
    "section": "Type coercion",
    "text": "Type coercion\nEvery element in a vector must have the same type\n\nc(1, \"Hello\")\n\n[1] \"1\"     \"Hello\"\n\n# Notice, the num 1 is coerced into \"1\" (a character)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#combining-vectors",
    "href": "notes/lesson-notes/03-Data-Types.html#combining-vectors",
    "title": "Data types and structures",
    "section": "Combining vectors",
    "text": "Combining vectors\n\nvec1 &lt;- 1:3\nvec2 &lt;- 5\n\nc(vec1, vec2)\n\n[1] 1 2 3 5\n\nc(vec1, 4, 5)\n\n[1] 1 2 3 4 5",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#matrices---vectors-in-higher-dimensions",
    "href": "notes/lesson-notes/03-Data-Types.html#matrices---vectors-in-higher-dimensions",
    "title": "Data types and structures",
    "section": "Matrices - vectors in higher dimensions",
    "text": "Matrices - vectors in higher dimensions\n\nmatrix(1:6, nrow = 3, ncol = 2)\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#lists",
    "href": "notes/lesson-notes/03-Data-Types.html#lists",
    "title": "Data types and structures",
    "section": "Lists",
    "text": "Lists\nLists can contain elements of different class/type and length, and elements can be named:\n\nlist1 &lt;- list(\n  a = c(\"a\", \"b\"),\n  b = c(TRUE, FALSE, TRUE, TRUE),\n  \"Some text here\",\n  c = NULL,\n  \"More text\"\n)\nlist1\n\n$a\n[1] \"a\" \"b\"\n\n$b\n[1]  TRUE FALSE  TRUE  TRUE\n\n[[3]]\n[1] \"Some text here\"\n\n$c\nNULL\n\n[[5]]\n[1] \"More text\"\n\n\n(Actually, vectors can also have named elements)",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#data.frames",
    "href": "notes/lesson-notes/03-Data-Types.html#data.frames",
    "title": "Data types and structures",
    "section": "Data.frames",
    "text": "Data.frames\n\ndf &lt;- data.frame(\n  x = 1:4, \n  y = c(100,200,100,200),\n  z = c(\"word1\", \"word2\", \"word3\", \"word4\")\n)\ndf\n\n  x   y     z\n1 1 100 word1\n2 2 200 word2\n3 3 100 word3\n4 4 200 word4\n\n\n\nlist2 &lt;- list(\n  a = c(\"a\", \"b\"),\n  b = c(TRUE, FALSE, TRUE, TRUE),\n  c = NULL,\n  df,\n  my_plot = df |&gt; ggplot(aes(x=x, y=y)) + geom_point()\n)\nlist2\n\n$a\n[1] \"a\" \"b\"\n\n$b\n[1]  TRUE FALSE  TRUE  TRUE\n\n$c\nNULL\n\n[[4]]\n  x   y     z\n1 1 100 word1\n2 2 200 word2\n3 3 100 word3\n4 4 200 word4\n\n$my_plot",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#factors",
    "href": "notes/lesson-notes/03-Data-Types.html#factors",
    "title": "Data types and structures",
    "section": "Factors",
    "text": "Factors\nCharacter vectors with specific levels\n\nc(\"cat\", \"c\", \"Dog\", \"Dog\", \"cat\") |&gt; \n  factor(levels = c(\"cat\", \"c\", \"Dog\"), \n         labels = c(\"Cat\", \"Cat\", \"Dog\"))\n\n[1] Cat Cat Dog Dog Cat\nLevels: Cat Dog",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#dates-and-date-times-yyyy-mm-dd",
    "href": "notes/lesson-notes/03-Data-Types.html#dates-and-date-times-yyyy-mm-dd",
    "title": "Data types and structures",
    "section": "Dates and Date-times (yyyy-mm-dd)",
    "text": "Dates and Date-times (yyyy-mm-dd)\n\n# Types\n\"1970-01-01\" |&gt; as.Date()\n\n[1] \"1970-01-01\"\n\n\"2001-04-01 07:30:00\" |&gt; as.POSIXct()\n\n[1] \"2001-04-01 07:30:00 CEST\"\n\n\nNotes, dates start at 1970-01-01\n\n# Day 0\nas.Date(0)\n\n[1] \"1970-01-01\"\n\nas.numeric(as.Date(\"1969-01-01\"))\n\n[1] -365\n\n\nBecause dates are just numbers behind-the-scenes, R can directly plot dates\n\n# Plotting and calculations\ndf_n &lt;- 500\ndf &lt;- tibble::tibble(\n  date = as.Date(runif(df_n, min = 0, max = 730)),\n  y = as.numeric(date) * 0.2 + rnorm(df_n, 0, 100)\n)\n\nwith(df, plot(date, y, pch=\".\"))\n\n\n\n\n\n\n\n\nAnd even perform regression analyses on them\n\ndf |&gt; ggplot(aes(x = date, y = y)) +\n  geom_point(alpha = 0.2, size = .6) +\n  geom_smooth(method = \"lm\", formula = y~x, se = T)\n\n\n\n\n\n\n\n\n\nDifftime objects\n\ndiff &lt;- as.Date(\"1970-01-01\") - as.Date(\"1960-01-01\")\ndiff\n\nTime difference of 3653 days",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#tibble-tidyverse",
    "href": "notes/lesson-notes/03-Data-Types.html#tibble-tidyverse",
    "title": "Data types and structures",
    "section": "Tibble (tidyverse)",
    "text": "Tibble (tidyverse)\nTibbles are built sequentially (i.e., each column is created before the next one); this means that the values from one column can be used in defining the values of the next\n\ntibble &lt;- tibble(x=1:5, \n                 y = x + 5)\n\nSubsetting a single column from a tibble allows you to keep the data in tibble-form, whereas subsetting a single column from a df usually gives just the vector that formed that column\n\ndf &lt;- data.frame(x=1:5, \n                 y = 6:10)\ndf[,\"y\"]\n\n[1]  6  7  8  9 10\n\ntibble[,\"y\"]\n\n# A tibble: 5 × 1\n      y\n  &lt;dbl&gt;\n1     6\n2     7\n3     8\n4     9\n5    10\n\n# Unless you use the $ operator\ntibble$y \n\n[1]  6  7  8  9 10",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#data.table",
    "href": "notes/lesson-notes/03-Data-Types.html#data.table",
    "title": "Data types and structures",
    "section": "Data.table",
    "text": "Data.table\nA layer on top of data.frames. Comes from the {data.table} package. Useful for writing concise code and lightning fast for very large datasets.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#regular-expressions",
    "href": "notes/lesson-notes/03-Data-Types.html#regular-expressions",
    "title": "Data types and structures",
    "section": "Regular expressions",
    "text": "Regular expressions\nThese are pattern matching tools; useful when you want to match text but don’t want to or are unable to match every single instance of text exactly.\n\npattern &lt;- \"^cat_[1-3]\" # reads as \"starts with cat_ and is followed by a digit of 1, 2 or 3.\"\nvec &lt;- c(\"cat_3\", \"dog_3\", \"cat_1\", \"cat_4\")\n\n# Check which elements of vec match the pattern\ngrepl(pattern, vec)\n\n[1]  TRUE FALSE  TRUE FALSE",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#factors-1",
    "href": "notes/lesson-notes/03-Data-Types.html#factors-1",
    "title": "Data types and structures",
    "section": "Factors",
    "text": "Factors\nTo turn a factor into its index in the ordering of its levels, use as.numeric():\n\nvec |&gt; factor() |&gt; as.numeric()\n\n[1] 2 4 1 3",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#parse-numbers",
    "href": "notes/lesson-notes/03-Data-Types.html#parse-numbers",
    "title": "Data types and structures",
    "section": "Parse numbers",
    "text": "Parse numbers\nTo turn text into numbers (e.g., when importing data from excel), as.numeric() is rather limited:\n\nc(\"2\", \"1234\", \"1,234\", \"$123\", \"\") |&gt; as.numeric()\n\nWarning: NAs introduced by coercion\n\n\n[1]    2 1234   NA   NA   NA\n\n\n{readr} has some nice parsing functions for various data types:\n\nreadr::parse_number(\"$1,234\")\n\n[1] 1234\n\nreadr::parse_number(\"$1.234\", locale = readr::locale(decimal_mark = \",\"))\n\n[1] 1234",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  },
  {
    "objectID": "notes/lesson-notes/03-Data-Types.html#work-with-logicals",
    "href": "notes/lesson-notes/03-Data-Types.html#work-with-logicals",
    "title": "Data types and structures",
    "section": "Work with logicals",
    "text": "Work with logicals\nImportant to know that logicals have three values (TRUE, FALSE and NA). When an expression is evaluated as NA, it does not interpret this as the expression evaluating to FALSE:\n\nx &lt;- 3\nifelse(x == 3, \"It's 3\",  \"It's not 3\")\n\n[1] \"It's 3\"\n\nx &lt;- 4\nifelse(x == 3, \"It's 3\",  \"It's not 3\")\n\n[1] \"It's not 3\"\n\nx &lt;- NA\nifelse(x == 3, \"It's 3\",  \"It's not 3\")\n\n[1] NA\n\n\nThat is NA == 3 will return NA. Same reason you can’t do\n\nx == NA\n\n[1] NA\n\n\nBut have to instead ask\n\nis.na(x)\n\n[1] TRUE\n\n\n\nFiltering\nWhen filtering things out from a dataset, knowing the logicals don’t automatically evaluate to FALSE when NAs are present is important, as rows can be dropped otherwise:\n\ndf &lt;- data.frame(\n  age = c(60,66,NA,50),\n  sex = c(1,2,2,2)\n)\ndf |&gt; filter(age &gt; 60) # This only keeps those with KNOWN age &gt; 60\n\n  age sex\n1  66   2\n\ndf |&gt; filter(!age &gt; 60)\n\n  age sex\n1  60   1\n2  50   2\n\n\nNote, even though age &gt; 60 and !age &gt; 60 seem like complements of each other, the two new datasets combined have 3 rows, not 4. All NAs were dropped entirely.\nIn order to keep NAs you could specify\n\ndf |&gt; filter(is.na(age) | age &gt; 60)\n\n  age sex\n1  66   2\n2  NA   2\n\n\nTo get the complement of a filter, you can also use the new dplyr::filter_out() command:\n\ndf |&gt; filter(age &gt; 60)\n\n  age sex\n1  66   2\n\ndf |&gt; filter_out(age &gt; 60)\n\n  age sex\n1  60   1\n2  NA   2\n3  50   2\n\n\nThese two datasets combined now have every original row.",
    "crumbs": [
      "R Coding Café",
      "Lesson notes",
      "Data types and structures"
    ]
  }
]